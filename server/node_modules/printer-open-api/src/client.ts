import axios, { AxiosError } from 'axios';
import {BASE_URL, PATH_PREFIX} from './config';
import {User} from './users';
import {apiError, ApiErrorCode, BindPrintersParam, BindPrintersResult, FailedPrinterBindResult, FailedPrinterUnbindResult, PrinterBindResult, PrintParam, QueryTasksResult, Task, UnbindPrinterResult, UnbindPrintersParam} from './business_types';
import {ApiName, BaseRequest, BindPrinterResponse, BindPrintersRequest, ClearPendingTasksRequest, ClearPendingTasksResponse, Printer, PrinterStatus, PrinterStatusRequest, PrinterStatusResponse, PrintRequest, PrintResponse, QueryPrintersRequest, QueryPrintersResponse, QueryTasksRequest, QueryTasksResponse, RawTask, Response, RetCode, TaskPrintState, TaskStatusRequest, TaskStatusResponse, UnbindPrintersRequest, UnbindPrintersResponse} from './types';

export class Client {
    constructor(private _user: User) {}

    async bindPrinters(param: BindPrintersParam): Promise<BindPrintersResult> {
        if (!param.bindPrinterParams || !param.bindPrinterParams.length) {
            throw apiError(ApiErrorCode.CLIENT_INVALID_ARGUMENT, 'null or empty bindPrinterParams');
        }
        const baseRequest = this._prepareRequest(ApiName.BIND_PRINTERS);
        const printerContent = param.bindPrinterParams.reduce((accu, curr) => `${accu}\n${curr.sn}${curr.model? '#' + curr.model: ''}${curr.alias? '#' + curr.alias: ''}`, '').substring(1);
        const bindPrinterResponse = await this._sendRequest<BindPrinterResponse>({...baseRequest, printerContent} as BindPrintersRequest);
        this._validateCommonResponse(bindPrinterResponse);
        const bindResultData = bindPrinterResponse.data;
        const successfulResults = bindResultData.ok.map(data => this._parseBindResult(data));
        const failedResults = bindResultData.no.map(data => this._parseFailedResult(data));
        return {
            successfullyBindedPrinters: successfulResults,
            failedBindedPrinters: failedResults,
        };
    }

    private _parseBindResult(result: string): PrinterBindResult {
        const splitted = result.split('#');
        const [sn, model] = [splitted[0], splitted[1]];
        let alias = undefined;
        if (splitted.length == 3) {
            alias = splitted[2];
        }
        return {sn, model, alias};
    }

    private _parseFailedResult(result: string): FailedPrinterBindResult {
        const partial = this._parseBindResult(result);
        if (partial.alias) {
            // extract err
            const [alias, errorMessage] = this._extractErrorMessage(partial.alias);
            return {
                ...partial,
                alias,
                failureReason: errorMessage,
            };
        }
        const [model, errorMessage] = this._extractErrorMessage(partial.model);
        return {
            ...partial,
            model,
            failureReason: errorMessage,
        };
    }

    private _extractErrorMessage(textWithErrorMessage: string): string[] {
        const splitted = textWithErrorMessage.split('(error:');
        return [splitted[0].trim(), splitted[1].substring(0, splitted[1].length - 1).trim()];
    }

    async print(param: PrintParam): Promise<string> {
        if (!param.sn || !param.content) {
            throw apiError(ApiErrorCode.CLIENT_INVALID_ARGUMENT, 'missing serial number or print content');
        }
        if (param.times && (param.times < 0 || param.times > 10)) {
            throw apiError(ApiErrorCode.CLIENT_INVALID_ARGUMENT, `print times can't be less than 0 or larger than 10`);
        }
        const baseRequest = this._prepareRequest(ApiName.PRINT);
        const printResponse = await this._sendRequest<PrintResponse>({...baseRequest, ...param} as PrintRequest);
        this._validateCommonResponse(printResponse);
        return printResponse.data;
    }

    async unbindPrinters(param: UnbindPrintersParam): Promise<UnbindPrinterResult> {
        if (!param.snList || !param.snList.length) {
            throw apiError(ApiErrorCode.CLIENT_INVALID_ARGUMENT, 'null or empty snList');
        }
        const baseRequest = this._prepareRequest(ApiName.UNBIND_PRINTERS);
        const snlist = [...new Set(param.snList)].reduce((accu, curr) => `${accu}&${curr}`, '').substring(1);
        const unbindResponse = await this._sendRequest<UnbindPrintersResponse>({...baseRequest, snlist} as UnbindPrintersRequest)
        this._validateCommonResponse(unbindResponse);
        const unbindResultData = unbindResponse.data;
        const successfulUnbindResults = unbindResultData.ok.map(sn => ({sn: this._parseUnbindResult(sn)[0]}));
        const failedUnbindResults = unbindResultData.no.map(data => this._parseFailedUnbindResult(data));
        return {successfullyUnBindedPrinters: successfulUnbindResults, failedUnBindedPrinters: failedUnbindResults};
    }

    private _parseUnbindResult(result: string): string[] {
        return result.split(' ').map(res => res.trim());
    }

    private _parseFailedUnbindResult(result: string): FailedPrinterUnbindResult {
        const splitted = this._parseUnbindResult(result);
        return {sn: splitted[0], failureReason: result.substring(splitted[0].length)};
    }

    async queryTaskPrintState(taskId: string): Promise<TaskPrintState> {
        if (!taskId) {
            throw apiError(ApiErrorCode.CLIENT_INVALID_ARGUMENT, 'null or empty task id');
        }
        const baseRequest = this._prepareRequest(ApiName.TASK_STATUS);
        const taskStateResponse = await this._sendRequest<TaskStatusResponse>({...baseRequest, orderid: taskId} as TaskStatusRequest);
        this._validateCommonResponse(taskStateResponse);
        return taskStateResponse.data? TaskPrintState.PRINTED: TaskPrintState.NOT_PRINTED;
    }

    async queryPrinterStatus(printerSN: string): Promise<PrinterStatus> {
         if (!printerSN) {
            throw apiError(ApiErrorCode.CLIENT_INVALID_ARGUMENT, 'null or empty printer serial number');
        }
        const baseRequest = this._prepareRequest(ApiName.PRINTER_STATUS);
        const printerStatusResponse = await this._sendRequest<PrinterStatusResponse>({...baseRequest, sn: printerSN} as PrinterStatusRequest);
        this._validateCommonResponse(printerStatusResponse);
        return printerStatusResponse.data;
    }

    async queryPrinterList(sn?: string): Promise<Printer[]> {
        const baseRequest = this._prepareRequest(ApiName.QUERY_PRINTERS);
        const printerListResponse = await this._sendRequest<QueryPrintersResponse>({...baseRequest, sn} as QueryPrintersRequest);
        this._validateCommonResponse(printerListResponse);
        return printerListResponse.data;
    }

    async queryPrintTasks(request?: {maxReferenceDate?: Date, limit?: number, printerSn?: string}): Promise<QueryTasksResult> {
      const maxReferenceDate = request?.maxReferenceDate?? new Date();
      const limit = request?.limit?? 20;
      const sn = request?.printerSn?? '';
      const baseRequest = this._prepareRequest(ApiName.QUERY_TASKS);
      const queryPrintTasksResponse = await this._sendRequest<QueryTasksResponse>({...baseRequest, maxReferenceTime: maxReferenceDate.toISOString(), limit: limit, sn: sn} as QueryTasksRequest);
      this._validateCommonResponse(queryPrintTasksResponse);
      const rawResult = queryPrintTasksResponse.data;
      const rawTasks = rawResult.tasks;
      const tasks = rawTasks.map(this._mapRawTaskToBisTask);
      const nextReferenceTime = rawResult.nextReferenceTime? new Date(rawResult.nextReferenceTime): undefined;
      return {tasks, nextReferenceTime};
    }

    private _mapRawTaskToBisTask(task: RawTask): Task {
      const bizTask: Task = {
        id: task.id,
        printerSn: task.printerSn,
        createdAt: new Date(task.createdAt),
        state: task.state === 0? TaskPrintState.NOT_PRINTED: TaskPrintState.PRINTED,
        expiredAt: undefined,
      };
      !!task.expiredAt && (bizTask.expiredAt = new Date(task.expiredAt));
      return bizTask;
    }

    async clearPendingTasks(sn: string): Promise<string[]> {
      const baseRequest = this._prepareRequest(ApiName.CLEAR_PENDING_TASKS);
      const clearPendingTasksResponse = await this._sendRequest<ClearPendingTasksResponse>({...baseRequest, sn: sn} as ClearPendingTasksRequest);
      this._validateCommonResponse(clearPendingTasksResponse);
      return clearPendingTasksResponse.data;
    }
    
    private _prepareRequest(apiName: string): BaseRequest {
        const stime = Math.floor(new Date().getTime() / 1000) + '';
        return {
            user: this._user.user,
            stime: stime,
            sig: this._user.getSignature(stime),
            apiname: apiName,
        };
    }

    private _validateCommonResponse(response: Response<unknown>) {
        switch (response.ret) {
            case RetCode.INVALID_SIG_OR_TIMESTAMP:
                throw apiError(ApiErrorCode.RESPONSE_ERROR, 'invalid signature or timestamp ' + response.msg?? '');
            case RetCode.EMPTY_REQUEST:
                throw apiError(ApiErrorCode.RESPONSE_ERROR, 'empty request ' + response.msg?? '');
            case RetCode.INVALID_REQUEST:
                throw apiError(ApiErrorCode.RESPONSE_ERROR, 'invalid request ' + response.msg?? '');
            case RetCode.UNMATCHED_PRINTER_USER_RELATION:
                throw apiError(ApiErrorCode.RESPONSE_ERROR, 'insufficient permission ' + response.msg?? '');
            case RetCode.WRONG_REQUEST_HEADER:
                throw apiError(ApiErrorCode.RESPONSE_ERROR, 'wrong request header ' + response.msg?? '');
            default:
                return;
        }
    }

    private async _sendRequest<T>(request: BaseRequest): Promise<T> {
        try {
            const axiosResponse = await axios.post<T>(`${BASE_URL}${PATH_PREFIX}`, request, {headers: {'content-type': 'application/x-www-form-urlencoded'}});
            return axiosResponse.data;
        } catch (error) {
            if (axios.isAxiosError(error)) {
                console.error('error message: ', error.message);
                const axiosErr = error as AxiosError;
                throw apiError(ApiErrorCode.NETWORK_ERROR, error.message);
              } else {
                console.error('unexpected error: ', error);
                throw apiError(ApiErrorCode.UNKNOWN, error + '');
              }
        }
    }
}
